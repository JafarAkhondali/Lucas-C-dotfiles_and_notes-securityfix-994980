# Thx to Justin Mason for that

[diff]
    renames = true

[color]
    ui = true

[alias]

# Some obvious short-form aliases
    st = status
    co = checkout
    ci = commit
    ca = commit -a
    br = branch
    p = pull

    mvbranch = branch -m
    unadd = reset HEAD

# Output the basic content of a .gitignore file
    genignore = "!echo .gitignore,nohup.out,.project,.classpath,*.pyc,*.o,*.class,*~ | tr , \\\\n"

# Get the full history of the changes affecting a given line, using a regular expression
# USAGE: -L '/REGEX/,+1' -M FILE
    rblame      = "!sh -c 'while line=$(git blame \"$@\" $commit 2>/dev/null); do commit=${line:0:8}^; [ 00000000^ == $commit ] && commit=$(git rev-parse HEAD); echo $line; done' dumb_param"
    rblameshow  = "!sh -c 'while line=$(git blame \"$@\" $commit 2>/dev/null); do commit=${line:0:8}^; [ 00000000^ == $commit ] && commit=$(git rev-parse HEAD); git show $commit; done' dumb_param"

# colored logs, one per line
    dag = log --graph --format='format:%C(yellow)%h%C(reset) %C(blue)\"%an\" <%ae>%C(reset) %C(magenta)%cr%C(reset)%C(auto)%d%C(reset)%n%s' --date-order
    lg = log --color --graph --pretty=format:'%Cred%h%Creset -%C(yellow)%d%Creset %s %Cgreen(%cr) %C(bold blue)<%an>%Creset' --abbrev-commit --
# Log using color, pager, and a graphical representation of branches/merges
    l =!git log --pretty=format:'%Cred---------------------------------------------------------------%n%C(red)%h %C(yellow)%d %Cgreen(%ci) %C(red)<%ae>%Creset%n%s%n%n%b%n' --abbrev-commit --date=relative --graph --date-order --stat --color | less -cR

# Better UI for common diff command: diff against upstream, use color & pager
    d =!git diff --patience --color origin/mainline | less -cR

# See diffstat(1) for info about what this looks like
    diffstat = diff --stat -r

# Show info about the last commit
    last = log -1 HEAD

# Generate a ReviewBoard-compatible diff
    rb = diff --no-color -U999999

# Show the "upstream" remote branch which the local branch is tracking
    origin =!git for-each-ref --format='%(upstream:short)' $(git symbolic-ref HEAD)

# When 'you can’t quite fit what you’ve done into a commit but daren’t stray too far from now without a backup'
    snapshot = !git stash save "snapshot: $(date)" && git stash apply "stash@{0}"

    startfeature  = checkout -bi # Start a new feature on a new branch
    refresh =!git fetch origin && git rebase origin/mainline # Occasionally update from remote mainline
    finishfeature =!git fetch && git rebase origin/mainline && git checkout mainline && git merge –no-ff @{-1} # Update and Merge to local mainline

# To avoid commiting changes to tracked files
    assume   = update-index --assume-unchanged
    unassume = update-index --no-assume-unchanged
    assumed  = "!git ls-files -v | grep ^h | cut -c 3-"

[branch]
    autosetuprebase = always

[push]
    default = tracking

# I don't care about whitespace changes
[apply]
    whitespace = nowarn

[core]
    whitespace = -blank-at-eol,-blank-at-eof
    editor = vim
    pager = less -FMRiX

[user]
    name = Lucas Cimon
    email = lucas.cimon@gmail.com
