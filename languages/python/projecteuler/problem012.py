#!/usr/bin/env python3

# The sequence of triangle numbers is generated by adding the natural numbers.
# So the 7th triangle number would be 1 + 2 + 3 + 4 + 5 + 6 + 7 = 28. The first ten terms would be:
# 1, 3, 6, 10, 15, 21, 28, 36, 45, 55, ...
# Let us list the factors of the first seven triangle numbers:
#      1: 1
#      3: 1,3
#      6: 1,2,3,6
#     10: 1,2,5,10
#     15: 1,3,5,15
#     21: 1,3,7,21
#     28: 1,2,4,7,14,28
# We can see that 28 is the first triangle number to have over five divisors.
# What is the value of the first triangle number to have over five hundred divisors?

# Notes:
#     36: 1,2,3,4,6,9,12,18,36
#     45: 1,3,5,9,15,45

#   Experimentally, T > 45000150000 (<=> n > 300000)
#     [tested with sympy.ntheory.divisors (takes 4min) / numba.jit-ed naive divisors_count (takes 45s)]
#   Moved further with numba.prange (took 6min): T > 4500001500000 (<=> n > 3000000)

#   Experimentally, in the series of triangles, new records of T with high #divisors have only low prime factors
#   This is very relative, not absolute:
#     (n=1664) T=1385280: #168 (prime factors: [2, 3, 5, 13, 37])
#     (n=1728) T=1493856: #192 (prime factors: [2, 3, 7, 13, 19])
#     (n=2015) T=2031120: #240 (prime factors: [2, 3, 5, 7, 13, 31])

# LEMMES:
#   T = n(n+1)/2
#   T >> 250Â² (because srqt(T)>#D(T)/2)
#   if N has #D(N) divisors, 2*N does not necessarily has 2*#D(N) divisors (ex: 15)

# time ./problem012.py
#-> NOT SOLVED YET, too slow...

import sys

DIVISORS_GOAL = 5000

def gen_triangles_divisors_up_to(max_n, only_divisors_count=False, only_length_records=False):
    'For problem exploration'
    max_length = 0
    for n in range(1, max_n):
        T = n*(n+1)//2
        divs = sorted(divisors(T))
        if not only_length_records or len(divs) > max_length:
            third_field = '#%s' % len(divisors(T)) if only_divisors_count else ','.join(map(str, sorted(divisors(T))))
            print('({:3}) {:6}: {} (prime factors: {})'.format(n, T, third_field, prime_factors(T)))
        if len(divs) > max_length:
            max_length = len(divs)

def divisors(n):
    divs = [1]
    i = 2
    while i * i <= n:
        if n % i == 0:
            divs.append(i)
            if i != n // i:
                divs.append(n // i)
        i += 1
    divs.append(n)
    return divs

def divisors_count(n):
    count = 2  # 1 & n
    i = 2
    while i * i <= n:
        if n % i == 0:
            count += 1
            if i != n // i:
                count += 1
        i += 1
    return count

def prime_factors(n):
    f = []
    if n <= 1:
        return f
    i = 2
    while i * i <= n:
        if n % i == 0:
            f.append(i)
            while n % i == 0:
                n = n // i
        i += 1
    if n != 1:
        f.append(n)
    return f

if __name__ == '__main__':
    gen_triangles_divisors_up_to(6000, only_length_records=True, only_divisors_count=True)
    exit(0)
    for n in range(1, 3000000):
        T = n*(n+1)//2
        count = len(divisors(n))
        if count >= DIVISORS_GOAL:
            print(n, T)
            break
        if n % 1000 == 0:
            print('Progress: n=%s T=%s #divisors=%s' % (n, T, count), file=sys.stderr)
