FROM: http://third-bit.com/2007/03/27/beautiful-code-chapter-by-chapter.html

## Chapter 1 - A Regular Expression Matcher, by Brian Kernighan
shows how deep insight into a language and a problem can lead to a concise and elegant solution.

## Chapter 2 - Subversion's Delta Editor: Interface as Ontology, by Karl Fogel
starts with a well-chosen abstraction and demonstrates its unifying effects on the system's further development.

## Chapter 3 - The Most Beautiful Code I Never Wrote, by Jon Bentley
suggests how to measure a procedure without actually executing the procedure.

## Chapter 4 - Finding Things, by Tim Bray
draws together many strands in Computer Science in an exploration of a problem that is fundamental to many computing tasks.

## Chapter 5, Correct, Beautiful, Fast (In That Order): Lessons From Designing XML Verifiers, by Elliotte Rusty Harold
reconciles the often conflicting goals of thoroughness and good performance

## Chapter 6 - Framework for Integrated Test: Beauty through Fragility, by Michael Feathers
presents an example that breaks the rules and achieves its own elegant solution

## Chapter 7 - Beautiful Tests, by Alberto Savoia
shows how a broad, creative approach to testing can not only eliminate bugs but turn you into a better programmer

## Chapter 8 - On-the-Fly Code Generation for Image Processing, by Charles Petzold
drops down a level to improve performance while maintaining portability

## Chapter 9 - Top Down Operator Precedence, by Douglas Crockford
revives an almost forgotten parsing technique and shows its new relevance to the popular JavaScript language

## Chapter 10 - The Quest for an Accelerated Population Count, by Henry Warren
reveals the impact that some clever algorithms can have on even a seemingly simple problem

## Chapter 11 - Secure Communication: The Technology of Freedom, by Ashish Gulhati
presents the history of a bold solution to securing email, a long sought-for solution to a universal computing problem

## Chapter 12 - Growing Beautiful Code in BioPerl, by Lincoln Stein
shows how the combination of a flexible language and a custom-designed module can make it easy for people with modest programming skills to create powerful visualizations for their data

## Chapter 13 - The Design of the Gene Sorter, by Jim Kent
combines simple building blocks to produce a robust and valuable tool for gene researchers

## Chapter 14 - How Elegant Code Evolves With Hardware: The Case Of Gaussian Elimination, by Jack Dongarra and Piotr Luszczek
surveys the history of LINPACK and related major software packages, to show how assumptions must constantly be re-evaluated in the face of new computing architectures

## Chapter 15 - The Long-Term Benefits of Beautiful Design, by Adam Kolawa
explains how attention to good design principles many decades ago helped CERN's widely used mathematical library (the predecessor of LINPACK) stand the test of time

## Chapter 16 - The Linux Kernel Driver Model: The Benefits of Working Together, by Greg Kroah-Hartman
explains how many efforts by different collaborators to solve different problems led to the successful evolution of a complex, multithreaded system

## Chapter 17 - Another Level of Indirection, by Diomidis Spinellis
shows how the flexibility and maintainability of the FreeBSD kernel is promoted by abstracting operations done in common by many drivers and filesystem modules

## Chapter 18 - Python's Dictionary Implementation: Being All Things to All People, by Andrew Kuchling
explains how a careful design combined with accommodations for a few special cases allows a language feature to support many different uses

## Chapter 19 - Multi-Dimensional Iterators in NumPy, by Travis E. Oliphant
takes you through the deisgn steps that succeed in hiding complexity under a simple interface

## Chapter 20 - A Highly Reliable Enterprise System for NASA's Mars Rover Mission, by Ronald Mak
uses industry standards, best practices, and Java technologies to meet the requirements of a NASA expedition where reliability cannot be in doubt

## Chapter 21 - ERP5: Designing for Maximum Adaptability, by Rogerio Atem de Carvalho and Rafael Monnerat
shows how a powerful ERP systemsystem can be developed with free software tools and a flexible architecture

## Chapter 22 - A Spoonful of Sewage, by Bryan Cantrill
lets the reader accompany the author through a hair-raising bug scare and a clever solution that violated expectations

## Chapter 23 - Distributed Programming with MapReduce, by Jeff Dean and Sanjay Ghemawat
describes a system that provides an easy-to-use programming abstraction for large-scale distributed data processing at Google that automatically handles many difficult aspects of distributed computation, including automatic parallelization, load balancing, and failure handling

## Chapter 24 - Beautiful Concurrency, by Simon Peyton Jones
removes much of the difficulty of parallel program through Software Transactional Memory, demonstrated here using Haskell

## Chapter 25 - Syntactic Abstraction: The syntax-case Expander, by Kent Dybvig
shows how macros--a key feature of many languages and systems--can be protected in Scheme from producing erroneous output

## Chapter 26 - Labor-Saving Architecture: An Object-Oriented Framework for Networked Software, by William Otte and Douglas C. Schmidt
applies a range of standard object-oriented design techniques, such as patterns and frameworks, to distributed logging to keep the system flexible and modular

## Chapter 27 - Integrating Business Partners the RESTful Way, by Andrew Patzer
demonstrates a designer's respect for his programmers by matching the design of a B2B web service to its requirements

## Chapter 28 - Beautiful Debugging, by Andreas Zeller
shows how a disciplined approach to validating code can reduce the time it takes to track down errors

## Chapter 29 - Treating Code as an Essay, by Yukihiro Matsumoto
lays out some challenging principles that drove his design of the Ruby programming language, and that, by extension, will help produce better software in general

## Chapter 30 - When a Button Is All That Connects You to the World, by Arun Mehta
takes you on a tour through the astounding interface design choices involved in a text editing system that allow people with severe motor disabilities, like Professor Stephen Hawking, to communicate via a computer

## Chapter 31 - Emacspeak: The Complete Audio Desktop, by TV Raman
shows how Lisp's advice facility can be used with the Emacs to address a general need - generating rich spoken output - that cuts across all aspects of the Emacs environment, without modifying the underlying source code of a large software system

## Chapter 32 - Code in Motion, by Laura Wingerd and Christopher Seiwald
lists some simple rules that have unexpectedly strong impacts on programming accuracy

## Chapter 33 - Writing Programs for "The Book", by Brian Hayes
explores the frustrations of solving a seemingly simple problem in computational geometry, and its surprising resolution.
