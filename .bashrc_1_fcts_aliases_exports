#---------
# Exports
#---------
export EDITOR=vim

export HISTTIMEFORMAT="%F %T " # for 'history' formatting

export PATH=/bin:$PATH
export PATH=/sbin:$PATH
export PATH=/usr/bin:$PATH
export PATH=/usr/sbin:$PATH
export PATH=/usr/local/bin:$PATH
export PATH=/usr/local/sbin:$PATH
export PATH=$BASHRC_DIR/bin:$PATH

#----
# ls
#----
unset ls; unalias ls 2>/dev/null
export LS_COLORS="ln=target" # Avoid mixing all symlinks in same color, and anyway we alias ls with -F
alias l='ls -BF --color=always'
alias la='l -A'
alias ll='l -lhA'
alias lk='ll -rS'       # sort by size, smallest first
alias lt='ll -rt'       # sort by date, oldest first
alias lc='ll -rtc'      # sort by and show change time, oldest first
alias lu='ll -rtu'      # sort by and show access time, oldest first
alias lr='ll -R'        # recursive ls
lsp () {                # group files by their prefix
    ls -AB1 $@ | sed 's/\(.[^.]\+\).*/\1/' | sort | uniq -c
}
lse () {                # group files by their extension
    ls -AB1 $@ | awk -F'.' '{print $NF}' | sort | uniq -c
}

#------
# grep
#------
alias g='grep -i --color=always'
alias zg='zgrep -i --color=always' # zgrep also works on plain text files, but '-r' isn't supported
zgr () {
    local pattern=$1
    shift
    find -L $@ -type f | xargs zg $pattern
}

#-----
# git
#-----
alias gs='git status'
alias ga='git add'
alias gb='git branch'
alias gc='git checkout'
alias gd='git diff'
alias gdc='git diff --cached'
alias gdp='git diff -U999999999 --no-color origin/mainline..HEAD'
alias gl='git log'
alias gll='git log origin/mainline..HEAD' # local commits only
alias gri='git rebase --interactive origin/mainline'
alias gpr='git pull --rebase'
giti () {
    cat <<EOF
.gitignore
nohup.out
.project
.classpath
*.pyc
*.o
*.class
*~
EOF
}

#------------
# One-letter
#------------
alias e='$EDITOR'
alias b='cd "$OLDPWD"'
alias f='firefox'

#---------------
# Alias control
#---------------
pa () {                 # print aliases
    grep --color -h '^[[:space:]]*[[:alnum:]._-]* () {\|^[[:space:]]*alias [[:alnum:]._-]*=' ${BASHRC_DIR}/.bashrc*
    grep --color '[[:alnum:]]*=' ${BASHRC_DIR}/.bash_dirs
}

noalias () {            # 'which' without aliases
    which $1 | tail -1
}

alias_r () {            # recursively resolve an alias, handle pipes and nested aliases
    local cmd=$1
    local end_of_cmd
    while alias $cmd >/dev/null 2>&1; do
        local aliased=$(alias $cmd | sed "s/.*\([\'\"]\)\(.*\)\1/\2/")
        cmd=$(echo $aliased | awk '{ print $1 }')
        end_of_cmd="$(echo $aliased | awk '{ $1 = ""; print }') $end_of_cmd" # still contain delim=<space>
    done
    while echo $end_of_cmd | grep -q '|'; do
        cmd="$cmd ${end_of_cmd%%|*} |"
        end_of_cmd=$(alias_r ${end_of_cmd#*|})
    done
    echo $cmd $end_of_cmd
}
#TEST: alias ec='echo' ; alias dog='cat' ; alias boo='ec BOO | dog'

#---------
# Languages
#----------
unset make; unalias make 2>/dev/null
alias make='make -j3'
unset tkcon; unalias tkcon 2>/dev/null
alias tkcon='tkcon -load Tk'

alias py='ipython --pdb'
alias rmpyc='find -L . -name "*.pyc" | xargs rm -f'

# Rhino: http://www.mikechambers.com/blog/2003/12/06/shell-scripting-on-os-x-with-ecma-javascript/
alias js='java -cp js.jar org.mozilla.javascript.tools.shell.Main'


#------------------
# Stream processing
#------------------
alias tF='tail -F'
alias t5='tail -500'

alias lower='tr "[:upper:]" "[:lower:]"'
alias upper='tr "[:lower:]" "[:upper:]"'

urlencode () { perl -ne 'chomp; s/([^-_.~A-Za-z0-9])/sprintf("%%%02X", ord($1))/seg; print "$_\n"'; }
utf8 () { iconv -f ISO-8859-1 -t UTF-8 $1 -o ${2:-$1} ; }

alias funiq='awk {k[$0]++}END{for(i in k){printf("%7s %s\n", k[i], i);}}' # faster than 'sort | uniq'

# FROM: http://unix.stackexchange.com/questions/13731/is-there-a-way-to-get-the-min-max-median-and-average-of-a-list-of-numbers-in
# One-pass stable variance algo: http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Online_algorithm

stats () { # --no-header | awk '{print $3}'
    [ "$1" = "--no-header" ] || printf "%-12s %-12s %-12s %-12s %-12s %-12s %-12s %-12s %-12s %-12s %-12s\n"\
        1-SUM 2-COUNT 3-MEAN 4-STD_DEV 5-MIN 6-TP01 7-TP10 8-MEDIAN 9-TP90 10-TP99 11-MAX
    sort -n | awk 'BEGIN{n=0;sum=0;mean=0;M2=0}\
        /^[^#]/{a[n++]=$1;sum+=$1;delta=$1-mean;mean+=delta/n;M2+=delta*($1-mean)}\
        function tp(ratio){i=n*ratio-1;if(i<0){return a[0];}else{return a[int(i)];}}
        END{unbiased_variance=M2/(n-1);
        std_dev=sqrt(unbiased_variance);
        if((n%2)==1){median=a[int(n/2)];}\
        else{median=(a[n/2]+a[n/2-1])/2;}\
        printf "%-12s %-12s %-12s %-12s %-12s %-12s %-12s %-12s %-12s %-12s %-12s\n",\
            sum,n,mean,std_dev,a[0],tp(.01),tp(.1),median,tp(.9),tp(.99),a[n-1]}'
}

#--------
# Others
#--------
unset touch; unalias touch 2>/dev/null
touch () {              # touch [EPOCH] [+/-<modifier>] <files>
    local yymm=$(date +%y%m) dd=$(date +%d) HHMM=$(date +%H%M)
    if [ "$(echo $1 | lower)" = "epoch" ]; then
        yymm=7001
        dd=01
        HHMM=0000
        shift
    fi
    if [[ $1 =~ ^[+-][0-9] ]]; then
        dd=$(($dd$1))
        [ ${#dd} -eq 1 ] && dd=0$dd
        shift
    fi
    local stamp=$yymm$dd$HHMM
    { ! [[ $dd =~ ^[0-3][0-9]$ ]] || [ "$dd" -eq 0 ] || [ "$dd" -gt 31 ] ; } && { echo "Day modifier cannot be applied: $stamp" ; return ; }
    $(which touch) -t $stamp "$@"
}

unset man; unalias man 2>/dev/null
man () { $(which man) $@ && return ; help $@ 2> /dev/null && help $@ | less ; }

unset df; unalias df 2>/dev/null
alias df='df -h'
unset du; unalias du 2>/dev/null
alias du='du -sh'
unset diff; unalias diff 2>/dev/null
alias diff='echo "Try merge or diff3" && diff -b'

alias diffs='diff --side-by-side'

alias psf='ps -eo user,group,pid,ppid,tty,rss,start,etime,nice,%cpu,psr,args --sort=start_time 2>/dev/null'
alias pg='psf | g'

alias nav='nautilus "$PWD/"'
alias pdf='evince'

fopen () { firefox file://$(pwd)/$1 ; }

fqdn () { python -c "import socket ; print socket.gethostbyaddr(\"$@\")[0]" ; } # Better than 'getfqdn' as it will fail properly in case it doesn't find a match

findTxt () {            # | xargs -I{} grep -H PATTERN {} # | while read file; do ... done
    find -L "${@:-.}" -type f -exec file {} \; | grep ': [^/.]\+text' | sed 's/^\(.*\): .*$/\1/'
}

notabs () {             # Replace tabs by 4 spaces & remove trailing ones & spaces
    for f in $(findTxt "$@"); do
        sed -i -e 's/[     ]*$//g' "$f"
        sed -i -e 's/    /    /g' "$f"
    done
}

pid () { sh -c 'echo $PPID'; }
ppid () {
    local pid=${1:-$(sh -c 'echo $PPID')}
    echo $(ps --no-headers --format ppid --pid $pid)
}
# foo () { sh -c 'echo $PPID' ; local pid=$(sh -c 'echo $PPID'); echo $pid ; }
# Same values if invoked in a shell or by executing a ./script
# But differents if invoked in a $(cmd) or sourced.

timeout () {
    [ "${1:-}" = "-h" -o "${1:-}" = "--help" ] && { printf "USAGE: timeout [--no-msg] <delay-in-deconds> <cmd>\n  <cmd> can start with 'exec' to avoid creating a new process\n" ; return ; }
    local no_msg=false; [ "${1:-}" = "--no-msg" ] && { no_msg=true ; shift ; }
    local s=${1:?'Missing timeout parameters'} ; shift
    ( pid=$(sh -c 'echo $PPID')
      ( $no_msg || echo "Command launched with a ${s}s timeout. To let it live: kill $(sh -c 'echo $PPID')"
        sleep $s
        kill -9 $pid 2>/dev/null || true
      ) & "${@:?'Missing timeout command'}"
    )
}

tstp () {               # timestamp converter
    echo $@ | gawk '{print strftime("%c", $0)}'
    # Or date -d @$TIMESTAMP but neither work on OSX
}

# As it's slower, I'm not using rsync rsync --archive --progress --human-readable --partial --remove-sent-files'
# But the following script is 10 times slower than basic cp : to improve it, we would need a way to get read of most of strace output
cp_p()                  # cp with progress bar
{
    strace -q -e write cp -- "${1}" "${2}" 2>&1 | awk '{
        if (NR % int(total_size / 409600) == 0) {
            percent = NR * 409600 / total_size
            printf "%3d%% [", percent
            for (i=0;i<=percent;i++)
               printf "="
            printf ">"
            for (i=percent;i<100;i++)
               printf " "
            printf "]\r"
        }
    } END { print "" }' total_size=$(stat -c '%s' "${1}")
}

kill_cmd ()             # WIP - Kill every process starting with the pattern passed as a parameter
{
    while true; do
        local pid=$(ps -eo pid,args | egrep -e "[0-9]* /bin/bash $1" | grep -v grep | grep -o '[0-9]*')
        echo "Killing $(ps -eo pid,args | egrep -e "[0-9]* /bin/bash $1" | grep -v grep)"
        if [ -n "$pid" ]; then
            kill "$pid"
        else
            break
        fi
    done
}
