###########
# EXPORTS
###########
export EDITOR=vim

export PATH=/bin:$PATH
export PATH=/sbin:$PATH
export PATH=/usr/bin:$PATH
export PATH=/usr/sbin:$PATH
export PATH=/usr/local/bin:$PATH
export PATH=/usr/local/bsin:$PATH
export PATH=$BASHRC_DIR/bin:$PATH

##########
# ALIASES
##########
pa () {
    grep --color -h '^[[:space:]]*[[:alnum:]._-]* () {\|^[[:space:]]*alias [[:alnum:]._-]*=' ${BASHRC_DIR}/.bash*
    grep --color '[[:alnum:]]*=' ${BASHRC_DIR}/.bash_dirs
}

#----
# ls
#----
unset ls; unalias ls 2>/dev/null
export LS_COLORS="ln=target" # Avoid mixing all symlinks in same color, and anyway we alias ls with -F
alias l='ls -BF --color=always'
alias la='l -A'
alias ll='l -lhA'
alias lk='ll -rS'       # sort by size, smallest first
alias lt='ll -rt'       # sort by date, oldest first
alias lc='ll -rtc'      # sort by and show change time, oldest first
alias lu='ll -rtu'      # sort by and show access time, oldest first
alias lr='ll -R'        # recursive ls
lsp () {                # group files by their prefix
    ls -AB1 $@ | sed 's/\(.[^.]\+\).*/\1/' | sort | uniq -c
}
lse () {                # group files by their extension
    ls -AB1 $@ | awk -F'.' '{print $NF}' | sort | uniq -c
}

#------
# grep
#------
alias g='grep -i --color=always'
alias zg='zgrep -i --color=always' # zgrep also works on plain text files, but '-r' isn't supported
zgr () {
    local pattern=$1
    shift
    find -L $@ -type f | xargs zg $pattern
}

#-----
# git
#-----
alias gs='git status'
alias ga='git add'
alias gb='git branch'
alias gc='git checkout'
alias gd='git diff'
alias gdc='git diff --cached'
alias gdp='git diff -U999999999 --no-color origin/mainline..HEAD'
alias gl='git log'
alias gll='git log origin/mainline..HEAD' # local commits only
alias gri='git rebase --interactive origin/mainline'
alias gpr='git pull --rebase'
giti () {
    cat >>.gitignore <<EOF

# Universal
nohup.out
.project
.classpath
*.pyc
*.o
*.class
*~
EOF
}

#--------
# Redefs
#--------
unset diff; unalias diff 2>/dev/null
alias diff='diff -b'    # !! Won't work with sudo
unset df; unalias df 2>/dev/null
alias df='df -h'        # !! Won't work with sudo
unset du; unalias du 2>/dev/null
alias du='du -sh'       # !! Won't work with sudo
unset make; unalias make 2>/dev/null
alias make='make -j3'
unset tkcon; unalias tkcon 2>/dev/null
alias tkcon='tkcon -load Tk'

#------------
# One-letter
#------------
alias e='$EDITOR'
alias b='cd $OLDPWD'
alias f='firefox'

#--------
# Others
#--------
alias psf='ps -eo user,group,pid,ppid,tty,rss,start,time,nice,%cpu,psr,args 2>/dev/null'
alias pg='psf | g'
alias tF='tail -F'
alias t5='tail -500'
alias utf8='iconv -f ISO-8859-1 -t UTF-8 '
alias py='python'
alias rmpyc='find -L . -name "*.pyc" | xargs rm -f'

alias nav='nautilus $(pwd)/'
alias pdf='evince'


fopen () { ( firefox file://$(pwd)/$1 ) }


############
# FUNCTIONS
############

noalias () {            # which' without aliases
    which $1 | tail -1
}

unset man; unalias man 2>/dev/null
man () { $(which man) $@ || ( help $@ 2> /dev/null && help $@ | less ) }

unset touch; unalias touch 2>/dev/null
touch () {              # touch [EPOCH] [+/-<modifier>] <files>
    local yymm=$(date +%y%m) dd=$(date +%d) HHMM=$(date +%H%M)
    if [ "$(echo $1 | tr '[A-Z]' '[a-z]')" = "epoch" ]; then
        yymm=7001
        dd=01
        HHMM=0000
        shift
    fi
    if [[ $1 =~ ^[+-][0-9] ]]; then
        dd=$(($dd$1))
        [ ${#dd} -eq 1 ] && dd=0$dd
        shift
    fi
    local stamp=$yymm$dd$HHMM
    (! [[ $dd =~ ^[0-3][0-9]$ ]] || [ "$dd" -eq 0 ] || [ "$dd" -gt 31 ]) && echo "Day modifier cannot be applied: $stamp" && return
    $(which touch) -t $stamp $@
}

is_true () { ! ( [ -z "$1" ] || [[ "$1" =~ 0+ ]] || [[ "$1" =~ [Ff][Aa][Ll][Ss][Ee] ]] ) }

is_file_open () { ( lsof | grep $(readlink -f "$1") ) }

fqdn () { ( python -c "import socket ; print socket.getfqdn(\"$@\")" ) }

findTxt () { ( find -L "$@" -type f -exec file {} \; | grep text | cut -d':' -f1 ) }

notabs () {             # Replace tabs by 4 spaces & remove trailing ones & spaces
    for f in $(findTxt "$@"); do
        sed -i -e 's/[     ]*$//g' "$f"
        sed -i -e 's/    /    /g' "$f"
    done
}

tstp () {               # timestamp converter
    echo $@ | gawk '{print strftime("%c", $0)}'
    # Or date -d @$TIMESTAMP but neither work on OSX
}

alias_r () {      # recursively resolve an alias, handle pipes and nested aliases
    local cmd=$1
    local end_of_cmd 
    while alias $cmd >/dev/null 2>&1; do
        local aliased=$(alias $cmd | sed "s/.*\([\'\"]\)\(.*\)\1/\2/")
        cmd=$(echo $aliased | awk '{ print $1 }')
        end_of_cmd="$(echo $aliased | awk '{ $1 = ""; print }') $end_of_cmd" # still contain delim=<space>
    done
    while echo $end_of_cmd | grep -q '|'; do
        cmd="$cmd ${end_of_cmd%%|*} |"
        end_of_cmd=$(alias_r ${end_of_cmd#*|})
    done
    echo $cmd $end_of_cmd
}
#TEST: alias ec='echo' ; alias dog='cat' ; alias boo='ec BOO | dog'

# As it's slower, I'm not using rsync rsync --archive --progress --human-readable --partial --remove-sent-files'
# But the following script is 10 times slower than basic cp : to improve it, we would need a way to get read of most of strace output
cp_p()                  # cp with progress bar
{
    strace -q -e write cp -- "${1}" "${2}" 2>&1 | awk '{
        if (NR % int(total_size / 409600) == 0) {
            percent = NR * 409600 / total_size
            printf "%3d%% [", percent
            for (i=0;i<=percent;i++)
               printf "="
            printf ">"
            for (i=percent;i<100;i++)
               printf " "
            printf "]\r"
        }
    } END { print "" }' total_size=$(stat -c '%s' "${1}")
}

kill_cmd ()             # WIP - Kill every process starting with the pattern passed as a parameter
{
    while true; do
        pid=$(ps -eo pid,args | egrep -e "[0-9]* /bin/bash $1" | grep -v grep | grep -o '[0-9]*')
        echo "Killing $(ps -eo pid,args | egrep -e "[0-9]* /bin/bash $1" | grep -v grep)"
        if [ -n "$pid" ]; then
            kill "$pid"
        else
            break
        fi
    done
}
