#---------
# Exports
#---------
export DISPLAY=:0 # for xclip

export EDITOR=vim
vimhelp () { sed 's/^\(\(-\|[0-9]\.\) [^ ].*\)$/\1\\/' ${code:-~}/Vim.md | pandoc -s -f markdown -t man | man -l -; }

export HISTTIMEFORMAT="%F %T " # for 'history' formatting

export PATH=/bin
PATH=/sbin:$PATH
PATH=/usr/bin:$PATH
PATH=/usr/sbin:$PATH
PATH=/usr/local/bin:$PATH
PATH=/usr/local/sbin:$PATH
PATH=$BASHRC_DIR/bin:$PATH

#---------------
# Alias control
#---------------
pa () {                 # print aliases
    grep --color -h '^[[:space:]]*[[:alnum:]._-]* () {\|^[[:space:]]*alias [[:alnum:]._-]*=' ${BASHRC_DIR}/.bashrc*
    grep --color '[[:alnum:]]*=' ${BASHRC_DIR}/.bash_dirs
}

alias nofuncalias='type -P'
unfuncalias () {            # undefined any function/alias named as arg
    unset -f "$@"; unalias "$@" 2>/dev/null
}

alias_r () {            # recursively resolve an alias, handle pipes and nested aliases
    local cmd=$1
    local end_of_cmd
    while alias $cmd >/dev/null 2>&1; do
        local aliased=$(alias $cmd | sed "s/.*\([\'\"]\)\(.*\)\1/\2/")
        cmd=$(echo $aliased | awk '{ print $1 }')
        end_of_cmd="$(echo $aliased | awk '{ $1 = ""; print }') $end_of_cmd" # still contain delim=<space>
    done
    while echo $end_of_cmd | grep -q '|'; do
        cmd="$cmd ${end_of_cmd%%|*} |"
        end_of_cmd=$(alias_r ${end_of_cmd#*|})
    done
    echo $cmd $end_of_cmd
}
#TEST: alias ec='echo' ; alias dog='cat' ; alias boo='ec BOO | dog'

#----
# ls
#----
unfuncalias ls
alias l='ls -BF --color=always'
alias la='l -A'
alias ll='l -lhA'
alias lk='ll -rS'       # sort by size, smallest first
alias lt='ll -rt'       # sort by date, oldest first
alias lc='ll -rtc'      # sort by and show change time, oldest first
alias lu='ll -rtu'      # sort by and show access time, oldest first
alias lr='ll -R'        # recursive ls
lsp () {                # group files by their prefix
    ls -AB1 $@ | sed 's/\(.[^.]\+\).*/\1/' | sort | uniq -c
}
lse () {                # group files by their extension
    ls -AB1 $@ | awk -F'.' '{print $NF}' | sort | uniq -c
}

#------
# grep
#------
alias g='grep -i --color=always'
alias zg='zgrep -i --color=always' # zgrep also works on plain text files, but '-r' isn't supported
zgr () {
    local pattern=$1
    shift
    find -L $@ -type f | xargs zg $pattern
}

#-----
# git
#-----
alias gs='git status'
alias ga='git add'
alias gb='git branch'
alias gc='git checkout'
alias gd='git diff'
alias gdc='git diff --cached'
alias gdp='git diff -U999999999 --no-color origin/mainline..HEAD'
alias gl='git log'
alias gll='git log origin/mainline..HEAD' # local commits only
alias gri='git rebase --interactive'
alias gpr='git pull --rebase'

#------------
# One-letter
#------------
alias e='$EDITOR'
alias b='cd -'
alias f='firefox'

#---------
# Languages
#----------
unfuncalias make
alias make='make -j3'
unfuncalias tkcon
alias tkcon='tkcon -load Tk'

alias py='ipython --pdb'
rmpyc () { find -L ${1:-.} -name "*.pyc" | xargs rm -f; }

# Rhino: http://www.mikechambers.com/blog/2003/12/06/shell-scripting-on-os-x-with-ecma-javascript/
alias js='java -cp js.jar org.mozilla.javascript.tools.shell.Main'


#------------------
# Stream processing
#------------------
alias tF='tail -F'
alias t5='tail -500'

alias lower='tr "[:upper:]" "[:lower:]"'
alias upper='tr "[:lower:]" "[:upper:]"'

urlencode () { perl -ne 'chomp; s/([^-_.~A-Za-z0-9])/sprintf("%%%02X", ord($1))/seg; print "$_\n"'; }
urldecode () { sed -e's/%\([0-9A-F][0-9A-F]\)/\\\\\x\1/g' | xargs echo -e; } # don't handle '+'->' ' in a query
iconv_help () {
    local file=${1:-\$file}
    echo iconv -f ISO-8859-1 -t UTF-8 $file -o ${2:-$file.utf8}
    echo iconv -t 'ASCII//TRANSLIT//IGNORE' $file -o ${2:-$file.ascii}
    echo tail --bytes=+4 UTF8WithBom.txt \> UTF8WithoutBom.txt
}
alias utf8=iconv_help
nocrlf () { perl -pe 's/\r//g' "$@"; } # also: dos2unix
alias json_fmt='python -mjson.tool' # don't work well with non ascii

alias funiq="awk '"'{k[$0]++}END{for(i in k){printf("%7s %s\n", k[i], i);}}'"'" # faster than 'sort | uniq -c' BUT output is not sorted. Also, it's very easy to swap the output columns

# FROM: http://unix.stackexchange.com/questions/13731/is-there-a-way-to-get-the-min-max-median-and-average-of-a-list-of-numbers-in
# One-pass stable variance algo: http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Online_algorithm

stats () { # --no-header | awk '{print $3}'
    [ "$1" = "--no-header" ] || printf "%-10s %-10s %-10s %-10s %-10s %-10s %-10s %-10s %-10s %-10s %-10s\n"\
        1-SUM 2-COUNT 3-MEAN 4-STD_DEV 5-MIN 6-TP01 7-TP10 8-MEDIAN 9-TP90 10-TP99 11-MAX
    sort -n | awk 'BEGIN{n=0;sum=0;mean=0;M2=0}\
        /^[^#]/{a[n++]=$1;sum+=$1;delta=$1-mean;mean+=delta/n;M2+=delta*($1-mean)}\
        function tp(ratio){i=n*ratio-1;if(i<0){return a[0];}else{return a[int(i)];}}
        END{unbiased_variance=M2/(n-1);
        std_dev=sqrt(unbiased_variance);
        if((n%2)==1){median=a[int(n/2)];}\
        else{median=(a[n/2]+a[n/2-1])/2;}\
        printf "%-10s %-10s %-10s %-10s %-10s %-10s %-10s %-10s %-10s %-10s %-10s\n",\
            sum,n,mean,std_dev,a[0],tp(.01),tp(.1),median,tp(.9),tp(.99),a[n-1]}'
} # TODO: add 'MAD' 

#--------
# Others
#--------
unfuncalias touch
touch () {              # touch [EPOCH] [+/-$modifier] $files
    local yymm=$(date +%y%m) dd=$(date +%d) HHMM=$(date +%H%M)
    if [ "$(echo $1 | lower)" = "epoch" ]; then
        yymm=7001
        dd=01
        HHMM=0000
        shift
    fi
    if [[ $1 =~ ^[+-][0-9] ]]; then
        dd=$(($dd$1))
        [ ${#dd} -eq 1 ] && dd=0$dd
        shift
    fi
    local stamp=$yymm$dd$HHMM
    { ! [[ $dd =~ ^[0-3][0-9]$ ]] || [ "$dd" -eq 0 ] || [ "$dd" -gt 31 ] ; } && { echo "Day modifier cannot be applied: $stamp" ; return ; }
    $(nofuncalias touch) -t $stamp "$@"
}

unfuncalias man
man () {               # colored manual with 'help' as a fallback
    env \
        LESS_TERMCAP_mb=$(printf "\e[1;31m") \
        LESS_TERMCAP_md=$(printf "\e[1;31m") \
        LESS_TERMCAP_me=$(printf "\e[0m") \
        LESS_TERMCAP_se=$(printf "\e[0m") \
        LESS_TERMCAP_so=$(printf "\e[1;44;33m") \
        LESS_TERMCAP_ue=$(printf "\e[0m") \
        LESS_TERMCAP_us=$(printf "\e[1;32m") \
            $(nofuncalias man) "$@" && return
    help "$@" >/dev/null 2>&1 && help "$@" | less
}

mv () {
    rsync_massive_mv_tip "$@" || $(nofuncalias mv) "$@"
}

rsync_massive_mv_tip () {       # 'mv' suggesting 'rsync' for 'massive' src files & different partitions
    _get_cp_mv_src_args "$@" >/dev/null || return 1
    _is_massive_cp_mv_src "$@" || return 2
    local src_args_partitions=$(_get_cp_mv_src_args "$@" | xargs df -P | sort | uniq | sed '$d' | awk '{print $1}')

    _get_cp_mv_dst_arg "$@" || return 3
    local dst_arg_partition=$(_get_cp_mv_dst_arg "$@" | xargs -n 1 dirname | xargs df -P | sort | uniq | sed '$d' | awk '{print $1}')

    local non_common_partitions=$(comm -23 <(echo $src_args_partitions | sort) <(echo "$dst_arg_partition" | sort))
    [ -z "$non_common_partitions" ] && return 4

    cat <<EOF
You're about to move a MASSIVE amount of files to another partition.
To first copy files and follow this task progress, I suggest using:
rsync -r --partial --progress --human-readable --ignore-times --rsh=/dev/null $@
If you want to ignore my advice, simply run:
$(nofuncalias mv) $@
EOF
}

cp () {                 # 'cp' suggesting 'rsync' to follow progress for 'massive' src files
    rsync_massive_cp_tip "$@" || $(nofuncalias cp) "$@"
}

rsync_massive_cp_tip () {
    _is_massive_cp_mv_src "$@" || return 1
    cat <<EOF
You're about to copy a MASSIVE amount of files. To follow this task progress, I suggest using:
rsync --partial --progress --human-readable --ignore-times --rsh=/dev/null $@
If you want to ignore my advice, simply run:
$(nofuncalias cp) $@
EOF
}

_is_massive_cp_mv_src () {      # 'massive' means >1000 files OR >100Mo
    [ -z "$1" ] && return 1
    local files_count_max_1000=$(_get_cp_mv_src_args "$@" | while read file; do find "$file" -type f; done | head -n 1000 | wc -l)
    [ ${files_count_max_1000:-0} -eq 1000 ] && return 0
    local src_args_size=$(_get_cp_mv_src_args "$@" | while read file; do du -sm "$file" | cut -f1; done | awk '{s+=$1} END {print s}')
    [ ${src_args_size:-0} -gt 100 ] && return 0
    return 1
}

_get_cp_mv_src_args () {
    while [[ "$1" =~ ^-[^t] ]]; do
        shift
    done
    if [ "$1" = "-t" ]; then
        shift; shift # removing -t $dst
        for arg in "$@"; do echo "$arg"; done
    else
        local argv=("$@")
        unset argv[${#argv[@]}-1] # removing last element: $dst
        for arg in "${argv[@]}"; do echo "$arg"; done
    fi
}

_get_cp_mv_dst_arg () {
    while [[ "$1" =~ -[^t] ]]; do
        shift
    done
    if [ "$1" = "-t" ]; then
        echo "$2"
    else
        local argv=("$@")
        echo "${argv[-1]}"
    fi
}

cp_p()                  # 'cp' showing progress, but slower than rsync and less portable
{
    strace -q -e write cp -- "${1}" "${2}" 2>&1 | awk '{
        if (NR % int(total_size / 409600) == 0) {
            percent = NR * 409600 / total_size
            printf "%3d%% [", percent
            for (i=0;i<=percent;i++)
               printf "="
            printf ">"
            for (i=percent;i<100;i++)
               printf " "
            printf "]\r"
        }
    } END { print "" }' total_size=$(stat -c '%s' "${1}")
}

unfuncalias df
alias df='df -hT'
unfuncalias du
alias du='du -sh'
unfuncalias diff
alias diff='echo "ALT: vimdiff (add color) / diff3 / opendiff (OSX) / diff --side-by-side -r --exclude=.git / sdiff -B -b -s # for %stats" && diff -b'
unfuncalias pstree
alias pstree='pstree -p'

alias psf='ps -eo user,pid,%cpu,%mem,ppid,tty,stat,rss,etime,start,nice,psr,args --sort=start_time 2>/dev/null'
alias pg='psf | g'

nav () { nautilus "${1:-$PWD}/"; }
alias pdf='evince'

fopen () { firefox file://$(pwd)/$1 ; }

fqdn () { python -c "import socket ; print socket.gethostbyaddr(\"$@\")[0]" ; } # Better than 'getfqdn' as it will fail properly in case it doesn't find a match

findTxt () {            # ! -iwholename '*.git*' | xargs -I{} grep -H PATTERN {} # | while read file; do ... done
    find -L "${@:-.}" -type f -exec file {} \; | grep text | sed 's/^\(.*\): .*$/\1/'
}
# Tests:
# - VALID: file.py: a adhoc-python2.7 script text executable

notabs () {             # Replace tabs by 4 spaces & remove trailing ones & spaces
    for f in $(findTxt "$@"); do
        perl -pi -e 's/[\t ]*$//g' "$f" # 'perl -p' is more portable than sed (e.g. \t\n does not work under OSX)
        perl -pi -e 's/\t/    /g' "$f"
    done
}

ext-ip () { curl http://ipecho.net/plain; echo; }
int-ips () { /sbin/ifconfig $1 | grep "inet[^0-9]" | sed 's/.*[^0-9]\([0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\)[^0-9].*/\1/' | grep -v '127\.0\.0\.1'; }

function memmost(){     # args: [proc_count=10] - Courtesy of fsquillace@
    local ps_out=$(psf)
    echo "$ps_out" | head -n 1
    echo "$ps_out" | sort -nr -k 4 | head -n ${1:-10}
}

function cpumost(){     # args: [proc_count=10] - Courtesy of fsquillace@
    local ps_out=$(psf)
    echo "$ps_out" | head -n 1
    echo "$ps_out" | sort -nr -k 3 | head -n ${1:-10}
}

mtr_proto () {
    local host=$1
    traceroute $host | \
        awk 'NR > 1 && $2 != "*" { sub(/^\(/,"",$3); sub(/)$/,"",$3); print $3 }'  | \
        xargs -r -L1 ping -n -i0.5 -c20 -s80 | tee $host.mtr
}

pid () { sh -c 'echo $PPID'; }
ppid () {
    local pid=${1:-$(sh -c 'echo $PPID')}
    echo $(ps --no-headers --format ppid --pid $pid)
}
# foo () { sh -c 'echo $PPID' ; local pid=$(sh -c 'echo $PPID'); echo $pid ; }
# Same values if invoked in a shell or by executing a ./script
# But differents if invoked in a $(cmd) or sourced.

timeout () {            # Alternative to coreutils 'timeout'
    if [ "${1:-}" = "-h" -o "${1:-}" = "--help" ]; then 
        printf "USAGE: timeout [--no-msg] \$delay_in_seconds \$cmd\n  \$cmd can start with 'exec' to avoid creating a new process\n"
        return
    fi
    local no_msg=false; [ "${1:-}" = "--no-msg" ] && { no_msg=true ; shift ; }
    local s=${1:?'Missing timeout parameters'} ; shift
    ( pid=$(sh -c 'echo $PPID')
      ( $no_msg || echo "Command launched with a ${s}s timeout. To let it live: kill $(sh -c 'echo $PPID')"
        sleep $s
        kill -9 $pid 2>/dev/null || true
      ) & "${@:?'Missing timeout command'}"
    )
}

tstp () {               # timestamp converter
    echo $@ | gawk '{print strftime("%c", $0)}'
    # Or date -d @$TIMESTAMP but neither work on OSX
}

if [ -e /proc/uptime ]; then
    dmesg () {
        $(nofuncalias dmesg) "$@" | perl -w -e 'use strict;
            my ($uptime) = do { local @ARGV="/proc/uptime";<>}; ($uptime) = ($uptime =~ /^(\d+)\./);
            foreach my $line (<>) {
                printf( ($line=~/^\[\s*(\d+)\.\d+\](.+)/) ? ( "[%s]%s\n", scalar localtime(time - $uptime + $1), $2 ) : $line )
            }'
    }
fi

kill_cmd ()             # WIP - Kill every process starting with the pattern passed as a parameter
{
    while true; do
        local pid=$(ps -eo pid,args | egrep -e "[0-9]* /bin/bash $1" | grep -v grep | grep -o '[0-9]*')
        echo "Killing $(ps -eo pid,args | egrep -e "[0-9]* /bin/bash $1" | grep -v grep)"
        if [ -n "$pid" ]; then
            kill "$pid"
        else
            break
        fi
    done
}
