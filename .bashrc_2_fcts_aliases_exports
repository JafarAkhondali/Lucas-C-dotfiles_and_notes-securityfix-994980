#---------
# Exports
#---------
export PATH=/bin
PATH=/sbin:$PATH
PATH=/usr/bin:$PATH
PATH=/usr/sbin:$PATH
PATH=/usr/local/bin:$PATH
PATH=/usr/local/sbin:$PATH
PATH=$BASHRC_DIR/bin:$PATH

export DISPLAY=:0 # for xclip, can be checked with 'w' cmd

export LOG=1 # for notify-osd

export LANG=C # makes many string-parsing tools faster: grep, sed...

export HISTCONTROL=ignoreboth # ignoredups and ignorespace
shopt -s histappend # append to the history file, don't overwrite it
export HISTSIZE=20000 # equivalent to HISTFILESIZE and .inputrc 'history-size'
export HISTTIMEFORMAT="%F %T "
alias r='fc -s' # 'repeat' - USAGE: r [old=new] [cmd] : runs last command [matching $cmd if provided], after performing the OLD=NEW substitution

#---------------
# Text display
#---------------
export EDITOR=vim
mkdir -p ~/.vim/undodir
vimhelp () { sed 's/^\(\(-\|[0-9]\.\) [^ ].*\)$/\1\\/' ${BASHRC_DIR}/misc/Vim.md | pandoc -s -f markdown -t man | man -l -; }

# make less more friendly for non-text input files, see lesspipe(1)
[ -x /usr/bin/lesspipe ] && eval "$(SHELL=/bin/sh lesspipe)"

diff_alt () {
    cat <<EOF
${_UNDER}ALT:${_END} \
diffs ${_UNDER}# == 'diff -U2 ... | diffstat' ${_END}; \
sdiff ${_UNDER}# == 'diff --side-by-side', but faster${_END} ; \
diff -r --exclude=.git ; \
vimdiff ${_UNDER}# colored side-by-side${_END} ; \
diff3 ; \
opendiff ${_UNDER}# OSX${_END}
EOF
}

alias diff='diff_alt && /usr/bin/diff -bB --suppress-common-lines'
alias sdiff='/usr/bin/sdiff -bB --suppress-common-lines'
diffs () { /usr/bin/diff -U2 "$@" | diffstat; }
alias less='/usr/bin/less --ignore-case --LONG-PROMPT'
alias make='/usr/bin/make -j3'
alias dmesg='dmesg --ctime' # Alt: http://stackoverflow.com/a/19272272
if type grc >/dev/null 2>&1; then # ALT: nojhan/colout
    alias cl='grc --stderr --stdout --colour=on'
    alias make='cl make -j3'
    cl_dmesg () { dmesg "$@" | grcat conf.proftpd; }
    alias dmesg=cl_dmesg
    alias gcc='cl gcc'
    alias g++='cl g++'
    alias as='cl as'
    alias ld='cl ld'
    alias netstat='cl netstat'
    alias ping='cl ping'
    alias traceroute='cl traceroute'
    alias diff='diff_alt && cl diff -b'
    alias tail='cl tail'
    colorless () {
        # --RAW-CONTROL-CHARS is required to print colors generated by 'grc'
        if [ $# -ne 0 ]; then
            grc --stderr --stdout cat "$@" | /usr/bin/less --ignore-case --LONG-PROMPT --RAW-CONTROL-CHARS
        elif [ -t 0 ]; then # nothing in stdin
            /bin/less
            return 1
        else
            grcat conf.log | /usr/bin/less --ignore-case --LONG-PROMPT --RAW-CONTROL-CHARS
        fi
    }
    alias less=colorless
fi

alias tF='tail -F'      # Alt: less + /search + SHIFT-F

#---------------
# Alias control
#---------------
pa () { # print aliases
    grep --color -h '^[[:space:]]*[[:alnum:]._-]* () {\|^[[:space:]]*alias [[:alnum:]._-]*=' ${BASHRC_DIR}/.bashrc*
    grep --color '[[:alnum:]]*=' ${BASHRC_DIR}/.bash_dirs
}

alias nofuncalias='type -P'
unfuncalias () { # undefined any function/alias named as arg
    unset -f "$@"; unalias "$@" 2>/dev/null
}

alias_r () { # recursively resolve an alias, handle pipes and nested aliases
    local cmd=$1
    local end_of_cmd
    while alias $cmd >/dev/null 2>&1; do
        local aliased=$(alias $cmd | sed "s/alias $cmd=\([\'\"]\)\(.*\)\1/\2/"| sed 's/^[^ ]\+=[^ ]\+ //g')
        cmd=$(echo $aliased | awk '{ print $1 }')
        end_of_cmd="$(echo $aliased | awk '{ $1 = ""; print }') $end_of_cmd" # still contain delim=<space>
    done
    while echo $end_of_cmd | grep -q '|'; do
        cmd="$cmd ${end_of_cmd%%|*} |"
        end_of_cmd=$(alias_r ${end_of_cmd#*|})
    done
    echo $cmd $end_of_cmd
}
#TEST: alias ec='echo' ; alias dog='cat' ; alias boo='ec BOO | dog'

#----
# ls
#----
alias l='LANG=en_US.UTF-8 ls -BF --color=always'
alias la='l -A'
alias ll='l -lhA'
alias lk='ll -rS'       # sort by size, smallest first
alias lt='ll -rt'       # sort by date, oldest first
alias lc='ll -rtc'      # sort by and show change time, oldest first
alias lu='ll -rtu'      # sort by and show access time, oldest first
alias lr='ll -R'        # recursive ls
lsp () { # group files by their prefix
    LANG=en_US.UTF-8 ls -AB1 $@ | sed 's/\(.[^.]\+\).*/\1/' | sort | uniq -c
}
lse () { # group files by their extension
    LANG=en_US.UTF-8 ls -AB1 $@ | awk -F'.' '{print $NF}' | sort | uniq -c
}

#------
# grep
#------
alias g='grep -i --color=always'
gn () { cd $BASHRC_DIR; g -I "$@" $(git ls-files); }
alias zg='zgrep -i --color=always' # zgrep also works on plain text files, but '-r' isn't supported
alias bzg='bzgrep -i --color=always'
zgr () {
    local pattern=$1
    shift
    find -L $@ -type f | xargs zg $pattern
}

#-----
# git
#-----
alias gst='git status'
alias gau='git add -u'
alias gdh='git diff HEAD'
alias gdc='git diff --cached'
alias gdp='git diff -U999999999 --no-color origin/mainline..HEAD'
alias gl='git log'
alias gll='git log origin/mainline..HEAD' # local commits only
alias gri='git rebase --interactive'
alias gpr='git pull --rebase'

#------------
# One-letter
#------------
alias e='$EDITOR'
alias b='cd -'
f () { ( nohup firefox "$@" >~/firefox.log 2>&1 & ); }

#---------
# Languages
#----------
alias tkcon='tkcon -load Tk'
alias ipy='PYTHONSTARTUP=$HOME/.pythonrc ipython --pdb'
alias py27='PYTHONSTARTUP=$HOME/.pythonrc python2.7'
alias py34='PYTHONSTARTUP=$HOME/.pythonrc python3.4'
rmpyc () { find -L ${1:-.} -name "*.pyc" | xargs rm -f; }
alias node='env NODE_NO_READLINE=1 rlwrap /usr/local/bin/node'
alias lua='rlwrap --always-readline lua'
alias lua5.2='rlwrap --always-readline lua5.2'

# Rhino: http://www.mikechambers.com/blog/2003/12/06/shell-scripting-on-os-x-with-ecma-javascript/
alias js='java -cp js.jar org.mozilla.javascript.tools.shell.Main'


#------------------
# Stream processing
#------------------
alias lower='tr "[:upper:]" "[:lower:]"'
alias upper='tr "[:lower:]" "[:upper:]"'

urlencode () { perl -ne 'chomp; s/([^-_.~A-Za-z0-9])/sprintf("%%%02X", ord($1))/seg; print "$_\n"'; }
urldecode () { sed -e's/%\([0-9A-F][0-9A-F]\)/\\\\\x\1/g' | xargs echo -e; } # don't handle '+'->' ' in a query
iconv_help () {
    local file=${1:-\$file}
    echo iconv -f ISO-8859-1 -t UTF-8 $file \> ${2:-$file.utf8}
    echo iconv -t 'ASCII//TRANSLIT//IGNORE' $file \> ${2:-$file.ascii}
    echo tail --bytes=+4 UTF8WithBom.txt \> UTF8WithoutBom.txt
}
alias utf8=iconv_help
nocrlf () { perl -pe 's/\r//g' "$@"; } # also: dos2unix
alias json_fmt='python -mjson.tool' # don't work well with non ascii

alias funiq="awk '"'{k[$0]++}END{for(i in k){printf("%7s %s\n", k[i], i);}}'"'" # faster than 'sort | uniq -c' BUT output is not sorted. Also, it's very easy to swap the output columns

# FROM: http://unix.stackexchange.com/questions/13731/is-there-a-way-to-get-the-min-max-median-and-average-of-a-list-of-numbers-in
# One-pass stable variance algo: http://en.wikipedia.org/wiki/Algorithms_for_calculating_variance#Online_algorithm

stats () { # --no-header | awk '{print $3}'
    [ "$1" = "--no-header" ] || printf "%-10s %-10s %-10s %-10s %-10s %-10s %-10s %-10s %-10s %-10s %-10s\n"\
        1-SUM 2-COUNT 3-MEAN 4-STD_DEV 5-MIN 6-TP01 7-TP10 8-MEDIAN 9-TP90 10-TP99 11-MAX
    sort -n | awk 'BEGIN{n=0;sum=0;mean=0;M2=0}\
        /^[^#]/{a[n++]=$1;sum+=$1;delta=$1-mean;mean+=delta/n;M2+=delta*($1-mean)}\
        function tp(ratio){i=n*ratio-1;if(i<0){return a[0];}else{return a[int(i)];}}
        END{unbiased_variance=M2/(n-1);
        std_dev=sqrt(unbiased_variance);
        if((n%2)==1){median=a[int(n/2)];}\
        else{median=(a[n/2]+a[n/2-1])/2;}\
        printf "%-10s %-10s %-10s %-10s %-10s %-10s %-10s %-10s %-10s %-10s %-10s\n",\
            sum,n,mean,std_dev,a[0],tp(.01),tp(.1),median,tp(.9),tp(.99),a[n-1]}'
}

#-------------------
# Command overrides
#-------------------
alias df='df -hT'
alias du='du -sh'
alias pstree='pstree -p'

man () { # colored manual with 'help' as a fallback
    env \
        LESS_TERMCAP_mb=$(printf "\e[1;31m") \
        LESS_TERMCAP_md=$(printf "\e[1;31m") \
        LESS_TERMCAP_me=$(printf "\e[0m") \
        LESS_TERMCAP_se=$(printf "\e[0m") \
        LESS_TERMCAP_so=$(printf "\e[1;44;33m") \
        LESS_TERMCAP_ue=$(printf "\e[0m") \
        LESS_TERMCAP_us=$(printf "\e[1;32m") \
            /usr/bin/man "$@" && return
    help "$@" >/dev/null 2>&1 && help "$@" | less
}

#mv () {
#    rsync_massive_mv_tip "$@" || /bin/mv "$@"
#}

rsync_massive_mv_tip () { # 'mv' suggesting 'rsync' for 'massive' src files & different partitions
    _get_cp_mv_src_args "$@" >/dev/null || return 1
    _is_massive_cp_mv_src "$@" || return 2
    local src_args_partitions=$(_get_cp_mv_src_args "$@" | xargs df -P | sort | uniq | sed '$d' | awk '{print $1}')

    _get_cp_mv_dst_arg "$@" || return 3
    local dst_arg_partition=$(_get_cp_mv_dst_arg "$@" | xargs -n 1 dirname | xargs df -P | sort | uniq | sed '$d' | awk '{print $1}')

    local non_common_partitions=$(comm -23 <(echo $src_args_partitions | sort) <(echo "$dst_arg_partition" | sort))
    [ -z "$non_common_partitions" ] && return 4

    cat <<EOF
You're about to move a MASSIVE amount of files to another partition.
To first copy files and follow this task progress, I suggest using:
rsync -r --partial --progress --human-readable --ignore-times --rsh=/dev/null $@
If you want to ignore my advice, simply run:
/bin/mv $@
EOF
}

#cp () { # 'cp' suggesting 'rsync' to follow progress for 'massive' src files
#    rsync_massive_cp_tip "$@" || /bin/cp "$@"
#}

rsync_massive_cp_tip () {
    _is_massive_cp_mv_src "$@" || return 1
    cat <<EOF
You're about to copy a MASSIVE amount of files. To follow this task progress, I suggest using:
rsync --partial --progress --human-readable --ignore-times --rsh=/dev/null $@
If you want to ignore my advice, simply run:
/bin/cp $@
EOF
}

_is_massive_cp_mv_src () { # 'massive' means >1000 files OR >100Mo
    [ -z "$1" ] && return 1
    local files_count_max_1000=$(_get_cp_mv_src_args "$@" | while read file; do find "$file" -type f; done | head -n 1000 | wc -l)
    [ ${files_count_max_1000:-0} -eq 1000 ] && return 0
    local src_args_size=$(_get_cp_mv_src_args "$@" | while read file; do du -sm "$file" | cut -f1; done | awk '{s+=$1} END {print s}')
    [ ${src_args_size:-0} -gt 100 ] && return 0
    return 1
}

_get_cp_mv_src_args () {
    while [[ "$1" =~ ^-[^t] ]]; do
        shift
    done
    if [ "$1" = "-t" ]; then
        shift; shift # removing -t $dst
        for arg in "$@"; do echo "$arg"; done
    else
        local argv=("$@")
        unset argv[${#argv[@]}-1] # removing last element: $dst
        for arg in "${argv[@]}"; do echo "$arg"; done
    fi
}

_get_cp_mv_dst_arg () {
    while [[ "$1" =~ -[^t] ]]; do
        shift
    done
    if [ "$1" = "-t" ]; then
        echo "$2"
    else
        local argv=("$@")
        echo "${argv[-1]}"
    fi
}

cp_p () { # 'cp' showing progress, but slower than rsync and less portable. Alt: Xfennec/cv
    strace -q -e write cp -- "${1}" "${2}" 2>&1 | awk '{
        if (NR % int(total_size / 409600) == 0) {
            percent = NR * 409600 / total_size
            printf "%3d%% [", percent
            for (i=0;i<=percent;i++)
               printf "="
            printf ">"
            for (i=percent;i<100;i++)
               printf " "
            printf "]\r"
        }
    } END { print "" }' total_size=$(stat -c '%s' "${1}")
}

touch () { # touch [EPOCH] [+/-$modifier] $files
    local yymm=$(date +%y%m) dd=$(date +%d) HHMM=$(date +%H%M)
    if [ "$(echo $1 | lower)" = "epoch" ]; then
        yymm=7001
        dd=01
        HHMM=0000
        shift
    fi
    if [[ $1 =~ ^[+-][0-9] ]]; then
        dd=$(($dd$1))
        [ ${#dd} -eq 1 ] && dd=0$dd
        shift
    fi
    local stamp=$yymm$dd$HHMM
    { ! [[ $dd =~ ^[0-3][0-9]$ ]] || [ "$dd" -eq 0 ] || [ "$dd" -gt 31 ] ; } && { echo "Day modifier cannot be applied: $stamp" ; return ; }
    /bin/touch -t $stamp "$@"
}


#-------
# Other
#-------

alias psf='ps -eo user,pid,%cpu,%mem,ppid,tty,stat,rss,etime,start,nice,psr,args --sort=start_time 2>/dev/null'
alias pg='psf | g'

nav () { nautilus "${1:-$PWD}/"; }

alias pdf='evince'
pdf_pages_extract () {
    local filename=${1:?'Missing or empty filename'}
    local first_page=${2:?'Missing or empty page range'}
    local last_page=${3:-$first_page}
    gs -sDEVICE=pdfwrite -dNOPAUSE -dBATCH -dSAFER \
        -dFirstPage=$first_page -dLastPage=$last_page \
        -sOutputFile="${filename%.pdf}_p${first_page}-p${last_page}.pdf" "$filename"
}

findTxt () { # ! -iwholename '*.git*' | xargs -I{} grep -H PATTERN {} # | while read file; do ... done
    find -L "${@:-.}" -type f -exec file {} \; | grep text | sed 's/^\(.*\): .*$/\1/'
}
# Tests:
# - VALID: file.py: a adhoc-python2.7 script text executable

notabs () { # INPLACE Replace tabs by 4 spaces & remove trailing ones & spaces
    for f in $(findTxt "$@"); do
        perl -pi -e 's/[\t ]*$//g' "$f" # 'perl -p' is more portable than sed (e.g. \t\n does not work under OSX)
        perl -pi -e 's/\t/    /g' "$f"
    done
}

fqdn () { python -c "import socket ; print socket.gethostbyaddr(\"$@\")[2]" ; } # Better than 'getfqdn' as it will fail properly in case it doesn't find a match
ext-ip () { dig +short myip.opendns.com @resolver1.opendns.com; } # faster than HTTP, e.g. ipecho.net/plain checkip.dyndns.org ifconfig.me
int-ips () { /sbin/ifconfig $1 | grep "inet[^0-9]" | sed 's/.*[^0-9]\([0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\.[0-9]\{1,3\}\)[^0-9].*/\1/' | grep -v '127\.0\.0\.1'; }

mtr_proto () {
    local host=$1
    traceroute $host | \
        awk 'NR > 1 && $2 != "*" { sub(/^\(/,"",$3); sub(/)$/,"",$3); print $3 }'  | \
        xargs -r -L1 ping -n -i0.5 -c20 -s80 | tee $host.mtr
}

FIFTY_NON_SHADY_NOR_GREY_HASHES='##################################################'
progress_bar () { # receive a serie of integers in {1..100} as input and update a unique progress bar line accordingly
    local percent
    while read percent; do
        printf "\r%-50s (%-3s%%)" ${FIFTY_NON_SHADY_NOR_GREY_HASHES:0:$((percent / 2))} $percent
    done
    echo
}

proc_read_fd_progress () { # args: $pid [$fd]
    # FROM: https://blogs.oracle.com/ksplice/entry/solving_problems_with_proc
    local pid=${1:?'Missing pid first argument'}
    ! [ -e /proc/$pid/ ] && echo "No process found with PID=$pid" >&2 && return 1
    local fd=$2
    if [ -z "${fd:-}" ]; then
        readlink /proc/$pid/fd/* | nl -v 0
        echo -n "Choose a file descriptor: "
        read fd
    fi
    local proc_fd=/proc/$pid/fd/$fd
    ! [ -e $proc_fd ] && echo "fd=$fd is not a valid file descriptor in /proc/$pid/fd/" >&2 && return 2
    local fd_size=$(wc -c $proc_fd | awk '{print $1}')
    echo "Progress reading '$(readlink $proc_fd)':"
    local percent_progress=0
    while [ -e $proc_fd ] && [ "$percent_progress" -ne 100 ] && ! read -n 1 -t 1 dummy; do
        local file_read_progress=$(grep ^pos /proc/$pid/fdinfo/$fd | awk '{print $2}')
        percent_progress=$((100 * $file_read_progress / $fd_size))
        echo $percent_progress
    done | progress_bar
}

memmost() { # args: [proc_count=10] - Courtesy of fsquillace@
    local ps_out=$(psf)
    echo "$ps_out" | head -n 1
    echo "$ps_out" | sort -nr -k 4 | head -n ${1:-10}
}

cpumost() { # args: [proc_count=10] - Courtesy of fsquillace@
    local ps_out=$(psf)
    echo "$ps_out" | head -n 1
    echo "$ps_out" | sort -nr -k 3 | head -n ${1:-10}
}

pid () { sh -c 'echo $PPID'; }
ppid () {
    local pid=${1:-$(sh -c 'echo $PPID')}
    echo $(ps --no-headers --format ppid --pid $pid)
}
# foo () { sh -c 'echo $PPID' ; local pid=$(sh -c 'echo $PPID'); echo $pid ; }
# Same values if invoked in a shell or by executing a ./script
# But differents if invoked in a $(cmd) or sourced.

unfuncalias alert
alert () { # USAGE: $long_cmd; alert - Logs: ~/.cache/notify-osd.log
    notify-send --urgency=low -i "$([ $? = 0 ] && echo terminal || echo error)" "$(history | tail -n1 | sed -e 's/^\s*[0-9]\+\s*//;s/[;&|]\s*alert$//')";
}

if ! type -p timeout >/dev/null; then
    timeout () { # Alternative to coreutils 'timeout'
        if [ "${1:-}" = "-h" -o "${1:-}" = "--help" ]; then 
            printf "USAGE: timeout [--no-msg] \$delay_in_seconds \$cmd\n  \$cmd can start with 'exec' to avoid creating a new process\n"
            return
        fi
        local no_msg=false; [ "${1:-}" = "--no-msg" ] && { no_msg=true ; shift ; }
        local s=${1:?'Missing timeout parameters'} ; shift
        ( pid=$(sh -c 'echo $PPID')
          ( $no_msg || echo "Command launched with a ${s}s timeout. To let it live: kill $(sh -c 'echo $PPID')"
            sleep $s
            kill -9 $pid 2>/dev/null || true
          ) & "${@:?'Missing timeout command'}"
        )
    }
fi

whiteboard_picture_cleaner () { # args: $original_img_file $output_file - use ImageMagick - FROM: https://gist.github.com/lelandbatey/8677901
    convert "$1" -morphology Convolve DoG:15,100,0 -negate -normalize -blur 0x1 -channel RBG -level 60%,91%,0.1 "$2";
}

gif_framecount_reducer () { # args: $gif_path $frames_reduction_factor  
    local orig_gif="${1?'Missing GIF filename parameter'}"
    local reduction_factor=${2?'Missing reduction factor parameter'}
    # Extracting the delays between each frames
    local orig_delay=$(gifsicle -I "$orig_gif" | sed -ne 's/.*delay \([0-9.]\+\)s/\1/p' | uniq)
    # Ensuring this delay is constant
    [ $(echo "$orig_delay" | wc -l) -ne 1 ] \
        && echo "Input GIF doesn't have a fixed framerate" >&2 \
        && return 1
    # Computing the current and new FPS
    local new_fps=$(echo "(1/$orig_delay)/$reduction_factor" | bc)
    # Exploding the animation into individual images in /var/tmp
    local tmp_frames_prefix="/var/tmp/${orig_gif%.*}_"
    convert "$orig_gif" -coalesce +adjoin "$tmp_frames_prefix%05d.gif"
    local frames_count=$(ls "$tmp_frames_prefix"*.gif | wc -l)
    # Creating a symlink for one frame every $reduction_factor
    local sel_frames_prefix="/var/tmp/sel_${orig_gif%.*}_"
    for i in $(seq 0 $reduction_factor $((frames_count-1))); do
        local suffix=$(printf "%05d.gif" $i)
        ln -s "$tmp_frames_prefix$suffix" "$sel_frames_prefix$suffix"
    done
    # Assembling the new animated GIF from the selected frames
    convert -delay $new_fps "$sel_frames_prefix"*.gif "${orig_gif%.*}_reduced_x${reduction_factor}.gif"
    # Cleaning up
    rm "$tmp_frames_prefix"*.gif "$sel_frames_prefix"*.gif
}

tstp () { # timestamp converter
    echo $@ | gawk '{print strftime("%c", $0)}'
    # Or date -d @$TIMESTAMP but neither work on OSX
}

kill_cmd () { # WIP - Kill every process starting with the pattern passed as a parameter
    while true; do
        local pid=$(ps -eo pid,args | egrep -e "[0-9]* /bin/bash $1" | grep -v grep | grep -o '[0-9]*')
        echo "Killing $(ps -eo pid,args | egrep -e "[0-9]* /bin/bash $1" | grep -v grep)"
        if [ -n "$pid" ]; then
            kill "$pid"
        else
            break
        fi
    done
}
